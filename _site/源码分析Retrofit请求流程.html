<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8"/>
        <meta name="keywords" content="源码阅读,Retrofit" />
        <meta name="description" content="Retrofit 是 square 公司的另一款广泛流行的网络请求框架。" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title> 源码分析Retrofit请求流程  </title>
        <link rel="stylesheet" href="http://localhost:4000/css/default.css" type="text/css" />
        <link rel="stylesheet" href="http://localhost:4000/css/small.css" type="text/css" media="(max-width: 720px)"/>
        <link rel="stylesheet" href="http://localhost:4000/css/syntax.css" type="text/css" />
        <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon" />
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
    </head>
    <body>

<div class="container">
    <div class="nav">
    <div class="nav_nav">
        <a class="nav_a1" href="http://localhost:4000/">首页</a>
        <a href="http://localhost:4000/categories/">分类</a>
        <a class="nav_a1" href="http://localhost:4000/wiki/">维基</a>
        <a href="http://localhost:4000/links/">链接</a>
        <a class="nav_a1" href="http://localhost:4000/about/">关于</a>
    </div>
    <div class="nav_rss"><a href="http://localhost:4000/sitemap.xml" style="display:none;">SITEMAP</a><a href="http://localhost:4000/feed.xml" target="_blank">订阅</a></div>
</div>

    <div class="main">
        <h2> 源码分析Retrofit请求流程 </h2>
        <p><code class="highlighter-rouge">Retrofit</code> 是 <code class="highlighter-rouge">square</code> 公司的另一款广泛流行的网络请求框架。前面的一篇文章《源码分析OKHttp执行过程》已经对 <code class="highlighter-rouge">OkHttp</code> 网络请求框架有一个大概的了解。今天同样地对 <code class="highlighter-rouge">Retrofit</code> 的源码进行走读，对其底层的实现逻辑做到心中有数。</p>

<h4 id="0x00-基本用法">0x00 基本用法</h4>

<p><code class="highlighter-rouge">Retrofit</code> 的项目地址为：https://github.com/square/retrofit</p>

<p>打开项目目录下的 <code class="highlighter-rouge">samples</code> 文件夹，从这里可以浏览 <code class="highlighter-rouge">Retrofit</code> 项目的使用范例。在本文中打开<code class="highlighter-rouge">SimpleService.java</code> 这个类作为源码走读的入口。这个类很简单，展示了 <code class="highlighter-rouge">Retrofit</code> 的基本用法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SimpleService</span> <span class="o">{</span>
  <span class="c1">//定义接口请求地址</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">API_URL</span> <span class="o">=</span> <span class="s">"https://api.github.com"</span><span class="o">;</span>
  <span class="c1">//定义接口返回数据的实体类</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Contributor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">login</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">contributions</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Contributor</span><span class="o">(</span><span class="n">String</span> <span class="n">login</span><span class="o">,</span> <span class="kt">int</span> <span class="n">contributions</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">login</span> <span class="o">=</span> <span class="n">login</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">contributions</span> <span class="o">=</span> <span class="n">contributions</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">//定义网络请求接口</span>
  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">GitHub</span> <span class="o">{</span>
    <span class="c1">//这个是请求github项目代码贡献者列表的接口</span>
    <span class="c1">//使用@GET注解指定GET请求，并指定接口请求路径，使用大括号{}定义的参数，是形参，retrofit会把方法中的</span>
    <span class="c1">//@Path 传入到请求路径中</span>
    <span class="nd">@GET</span><span class="o">(</span><span class="s">"/repos/{owner}/{repo}/contributors"</span><span class="o">)</span>
    <span class="n">Call</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Contributor</span><span class="o">&gt;&gt;</span> <span class="nf">contributors</span><span class="o">(</span>
        <span class="nd">@Path</span><span class="o">(</span><span class="s">"owner"</span><span class="o">)</span> <span class="n">String</span> <span class="n">owner</span><span class="o">,</span>
        <span class="nd">@Path</span><span class="o">(</span><span class="s">"repo"</span><span class="o">)</span> <span class="n">String</span> <span class="n">repo</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="c1">// 创建一个retrofit，并且指定了接口的baseUrl</span>
    <span class="c1">// 然后设置了一个gson转换器，用于将接口请求下来的json字符串转换为Contributor实体类。</span>
    <span class="n">Retrofit</span> <span class="n">retrofit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Retrofit</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">baseUrl</span><span class="o">(</span><span class="n">API_URL</span><span class="o">)</span>
        <span class="o">.</span><span class="na">addConverterFactory</span><span class="o">(</span><span class="n">GsonConverterFactory</span><span class="o">.</span><span class="na">create</span><span class="o">())</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>

    <span class="c1">// 这里是魔法所在，retrofit将程序猿定义的接口变成“实现类”</span>
    <span class="n">GitHub</span> <span class="n">github</span> <span class="o">=</span> <span class="n">retrofit</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">GitHub</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="c1">//通过retrofit这个“实现类”执行contributors方法</span>
    <span class="n">Call</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Contributor</span><span class="o">&gt;&gt;</span> <span class="n">call</span> <span class="o">=</span> <span class="n">github</span><span class="o">.</span><span class="na">contributors</span><span class="o">(</span><span class="s">"square"</span><span class="o">,</span> <span class="s">"retrofit"</span><span class="o">);</span>

    <span class="c1">// 执行Call类中的execute方法，这是一个同步方法</span>
    <span class="c1">// 当然跟okhttp一样，异步方法是enqueue，这个下文会提到</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Contributor</span><span class="o">&gt;</span> <span class="n">contributors</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="na">execute</span><span class="o">().</span><span class="na">body</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Contributor</span> <span class="n">contributor</span> <span class="o">:</span> <span class="n">contributors</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">contributor</span><span class="o">.</span><span class="na">login</span> <span class="o">+</span> <span class="s">" ("</span> <span class="o">+</span> <span class="n">contributor</span><span class="o">.</span><span class="na">contributions</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>通过上面代码的阅读，知道 <code class="highlighter-rouge">retrofit</code> 使用流程</p>

<ol>
  <li>定义 <code class="highlighter-rouge">API</code></li>
  <li>构造接口数据实体类</li>
  <li>构造 <code class="highlighter-rouge">retrofit</code> 对象，指定<code class="highlighter-rouge">baseUrl</code>和数据转换器（即接口数据解析器，如对<code class="highlighter-rouge">json</code>、<code class="highlighter-rouge">xml</code>、<code class="highlighter-rouge">protobuf</code>等数据类型的解析）</li>
  <li>通过 <code class="highlighter-rouge">retrofit</code> 将程序猿定义的 <code class="highlighter-rouge">API</code> 接口变成”实现类”</li>
  <li>执行“实现类”的方法</li>
  <li>执行网络请求，获取接口请求数据</li>
</ol>

<p>这个流程关键点是4、5、6，下文将详细对这几个步骤的源码进行阅读。</p>

<p>在继续下文之前，我们先看看这个<code class="highlighter-rouge">SimpleService</code>的执行结果，它打印了<code class="highlighter-rouge">retrofit</code> 这个项目的代码贡献者</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">JakeWharton</span> <span class="o">(</span><span class="mi">928</span><span class="o">)</span>
<span class="n">swankjesse</span> <span class="o">(</span><span class="mi">240</span><span class="o">)</span>
<span class="n">pforhan</span> <span class="o">(</span><span class="mi">48</span><span class="o">)</span>
<span class="n">eburke</span> <span class="o">(</span><span class="mi">36</span><span class="o">)</span>
<span class="n">dnkoutso</span> <span class="o">(</span><span class="mi">26</span><span class="o">)</span>
<span class="n">NightlyNexus</span> <span class="o">(</span><span class="mi">26</span><span class="o">)</span>
<span class="n">edenman</span> <span class="o">(</span><span class="mi">24</span><span class="o">)</span>
<span class="n">loganj</span> <span class="o">(</span><span class="mi">17</span><span class="o">)</span>
<span class="n">Noel</span><span class="o">-</span><span class="mi">96</span> <span class="o">(</span><span class="mi">16</span><span class="o">)</span>
<span class="n">rcdickerson</span> <span class="o">(</span><span class="mi">14</span><span class="o">)</span>
<span class="n">rjrjr</span> <span class="o">(</span><span class="mi">13</span><span class="o">)</span>
<span class="n">kryali</span> <span class="o">(</span><span class="mi">9</span><span class="o">)</span>
<span class="n">adriancole</span> <span class="o">(</span><span class="mi">9</span><span class="o">)</span>
<span class="n">holmes</span> <span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="n">swanson</span> <span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="n">JayNewstrom</span> <span class="o">(</span><span class="mi">6</span><span class="o">)</span>
<span class="n">crazybob</span> <span class="o">(</span><span class="mi">6</span><span class="o">)</span>
<span class="n">Jawnnypoo</span> <span class="o">(</span><span class="mi">6</span><span class="o">)</span>
<span class="n">danrice</span><span class="o">-</span><span class="n">square</span> <span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">vanniktech</span> <span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">Turbo87</span> <span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">naturalwarren</span> <span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">guptasourabh04</span> <span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="n">artem</span><span class="o">-</span><span class="n">zinnatullin</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">codebutler</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">icastell</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">jjNford</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">f2prateek</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">PromanSEW</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">koalahamlet</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="0x01-构造过程">0x01 构造过程</h4>

<p>从上文的源码阅读中，可以看出<strong>程序猿只是定义了一个接口，但是现在实现接口的工作是由 <code class="highlighter-rouge">retrofit</code> 来实现的</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GitHub</span> <span class="n">github</span> <span class="o">=</span> <span class="n">retrofit</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">GitHub</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="n">Call</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Contributor</span><span class="o">&gt;&gt;</span> <span class="n">call</span> <span class="o">=</span> <span class="n">github</span><span class="o">.</span><span class="na">contributors</span><span class="o">(</span><span class="s">"square"</span><span class="o">,</span> <span class="s">"retrofit"</span><span class="o">);</span>
</code></pre></div></div>

<h5 id="create">create</h5>

<p>打开 <code class="highlighter-rouge">retrofit.create</code>方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">create</span><span class="o">(</span><span class="kd">final</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//对接口进行校验</span>
    <span class="n">Utils</span><span class="o">.</span><span class="na">validateServiceInterface</span><span class="o">(</span><span class="n">service</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">validateEagerly</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">eagerlyValidateMethods</span><span class="o">(</span><span class="n">service</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//通过Proxy创建了一个代理</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">T</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">service</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="o">{</span> <span class="n">service</span> <span class="o">},</span>
        <span class="k">new</span> <span class="nf">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="kd">private</span> <span class="kd">final</span> <span class="n">Platform</span> <span class="n">platform</span> <span class="o">=</span> <span class="n">Platform</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
          <span class="kd">private</span> <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">emptyArgs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

          <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
              <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
            <span class="c1">// If the method is a method from Object then defer to normal invocation.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getDeclaringClass</span><span class="o">()</span> <span class="o">==</span> <span class="n">Object</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//判断是否为默认方法，Java8中接口也可以有默认方法，所以这里有这个判断</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">platform</span><span class="o">.</span><span class="na">isDefaultMethod</span><span class="o">(</span><span class="n">method</span><span class="o">))</span> <span class="o">{</span>
              <span class="k">return</span> <span class="n">platform</span><span class="o">.</span><span class="na">invokeDefaultMethod</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">service</span><span class="o">,</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//关键点</span>
            <span class="k">return</span> <span class="nf">loadServiceMethod</span><span class="o">(</span><span class="n">method</span><span class="o">).</span><span class="na">invoke</span><span class="o">(</span><span class="n">args</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">args</span> <span class="o">:</span> <span class="n">emptyArgs</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>这个方法很短，关键是通过 <code class="highlighter-rouge">Proxy</code> 创建了一个 <code class="highlighter-rouge">Github</code> 接口的代理类并返回该代理。</p>

<p><code class="highlighter-rouge">newProxyInstance</code> 方法需要3个参数：<code class="highlighter-rouge">ClassLoader</code>、<code class="highlighter-rouge">Class&lt;?&gt;</code>数组、<code class="highlighter-rouge">InvocationHandler</code> 回调。</p>

<p>这个 <code class="highlighter-rouge">InvocationHandler</code> 非常关键，当执行接口 <code class="highlighter-rouge">Github</code> 的<code class="highlighter-rouge">contributors</code>方法时，会委托给<code class="highlighter-rouge">InvocationHandler</code>的<code class="highlighter-rouge">invoke</code> 方法来执行。即<code class="highlighter-rouge">Github</code>将接口代理给了<code class="highlighter-rouge">Proxy</code>来执行了。</p>

<h5 id="invocationhandler">InvocationHandler</h5>

<p>接着看<code class="highlighter-rouge">InvocationHandler</code> 接口的实现。</p>

<p>在 <code class="highlighter-rouge">invoke</code> 方法中有三个参数，其中<code class="highlighter-rouge">proxy</code> 就是代理对象，而 <code class="highlighter-rouge">method</code> 就是程序猿定义的那个网络请求接口，顾名思义 <code class="highlighter-rouge">args</code> 就是方法的参数。</p>

<p>此方法最终是调用了</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">loadServiceMethod</span><span class="o">(</span><span class="n">method</span><span class="o">).</span><span class="na">invoke</span><span class="o">(</span><span class="n">args</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">args</span> <span class="o">:</span> <span class="n">emptyArgs</span><span class="o">);</span>
</code></pre></div></div>

<h5 id="loadservicemethod">loadServiceMethod</h5>

<p>打开 <code class="highlighter-rouge">loadServiceMethod</code>方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ServiceMethod</span><span class="o">&lt;?&gt;</span> <span class="n">loadServiceMethod</span><span class="o">(</span><span class="n">Method</span> <span class="n">method</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 判断是否有缓存</span>
  <span class="n">ServiceMethod</span><span class="o">&lt;?&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">serviceMethodCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="c1">//同步处理</span>
  <span class="kd">synchronized</span> <span class="o">(</span><span class="n">serviceMethodCache</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">serviceMethodCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//没有获取到缓存则使用`ServiceMethod`方法来创建</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">ServiceMethod</span><span class="o">.</span><span class="na">parseAnnotations</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">method</span><span class="o">);</span>
      <span class="c1">//最后缓存起来</span>
      <span class="n">serviceMethodCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法就是通过 <code class="highlighter-rouge">method</code> 来获取一个 <code class="highlighter-rouge">ServiceMethod</code> 对象。</p>

<h5 id="servicemethod">ServiceMethod</h5>

<p>打开 <code class="highlighter-rouge">ServiceMethod</code> 发现它是一个抽象类，有一个静态方法 <code class="highlighter-rouge">parseAnnotations</code> 和一个抽象方法 <code class="highlighter-rouge">invoke</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ServiceMethod</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ServiceMethod</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">parseAnnotations</span><span class="o">(</span><span class="n">Retrofit</span> <span class="n">retrofit</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//对注解进行解析</span>
    <span class="n">RequestFactory</span> <span class="n">requestFactory</span> <span class="o">=</span> <span class="n">RequestFactory</span><span class="o">.</span><span class="na">parseAnnotations</span><span class="o">(</span><span class="n">retrofit</span><span class="o">,</span> <span class="n">method</span><span class="o">);</span>
	<span class="c1">//获取方法的返回类型</span>
    <span class="n">Type</span> <span class="n">returnType</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getGenericReturnType</span><span class="o">();</span>
    <span class="c1">//对返回类型进行校验</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Utils</span><span class="o">.</span><span class="na">hasUnresolvableType</span><span class="o">(</span><span class="n">returnType</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="nf">methodError</span><span class="o">(</span><span class="n">method</span><span class="o">,</span>
          <span class="s">"Method return type must not include a type variable or wildcard: %s"</span><span class="o">,</span> <span class="n">returnType</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">returnType</span> <span class="o">==</span> <span class="kt">void</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="nf">methodError</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="s">"Service methods cannot return void."</span><span class="o">);</span>
    <span class="o">}</span>
	<span class="c1">//最终使用到HttpServiceMethod类</span>
    <span class="k">return</span> <span class="n">HttpServiceMethod</span><span class="o">.</span><span class="na">parseAnnotations</span><span class="o">(</span><span class="n">retrofit</span><span class="o">,</span> <span class="n">method</span><span class="o">,</span> <span class="n">requestFactory</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">abstract</span> <span class="n">T</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">parseAnnotations</code> 方法就是对程序猿定义的接口中使用的注解进行解析。</p>

<p>最后是使用了<code class="highlighter-rouge">HttpServiceMethod.parseAnnotations</code>方法</p>

<h5 id="httpservicemethod">HttpServiceMethod</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** Adapts an invocation of an interface method into an HTTP call. */</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="nc">HttpServiceMethod</span><span class="o">&lt;</span><span class="n">ResponseT</span><span class="o">,</span> <span class="n">ReturnT</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ServiceMethod</span><span class="o">&lt;</span><span class="n">ReturnT</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="o">&lt;</span><span class="n">ResponseT</span><span class="o">,</span> <span class="n">ReturnT</span><span class="o">&gt;</span> <span class="n">HttpServiceMethod</span><span class="o">&lt;</span><span class="n">ResponseT</span><span class="o">,</span> <span class="n">ReturnT</span><span class="o">&gt;</span> <span class="nf">parseAnnotations</span><span class="o">(</span>
      <span class="n">Retrofit</span> <span class="n">retrofit</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">RequestFactory</span> <span class="n">requestFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">CallAdapter</span><span class="o">&lt;</span><span class="n">ResponseT</span><span class="o">,</span> <span class="n">ReturnT</span><span class="o">&gt;</span> <span class="n">callAdapter</span> <span class="o">=</span> <span class="n">createCallAdapter</span><span class="o">(</span><span class="n">retrofit</span><span class="o">,</span> <span class="n">method</span><span class="o">);</span>
    <span class="c1">//...省略部分代码</span>
    <span class="n">Converter</span><span class="o">&lt;</span><span class="n">ResponseBody</span><span class="o">,</span> <span class="n">ResponseT</span><span class="o">&gt;</span> <span class="n">responseConverter</span> <span class="o">=</span>
        <span class="n">createResponseConverter</span><span class="o">(</span><span class="n">retrofit</span><span class="o">,</span> <span class="n">method</span><span class="o">,</span> <span class="n">responseType</span><span class="o">);</span>

    <span class="n">okhttp3</span><span class="o">.</span><span class="na">Call</span><span class="o">.</span><span class="na">Factory</span> <span class="n">callFactory</span> <span class="o">=</span> <span class="n">retrofit</span><span class="o">.</span><span class="na">callFactory</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">HttpServiceMethod</span><span class="o">&lt;&gt;(</span><span class="n">requestFactory</span><span class="o">,</span> <span class="n">callFactory</span><span class="o">,</span> <span class="n">callAdapter</span><span class="o">,</span> <span class="n">responseConverter</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="c1">//...省略部分代码</span>

  <span class="nd">@Override</span> <span class="n">ReturnT</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">callAdapter</span><span class="o">.</span><span class="na">adapt</span><span class="o">(</span>
        <span class="k">new</span> <span class="n">OkHttpCall</span><span class="o">&lt;&gt;(</span><span class="n">requestFactory</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="n">callFactory</span><span class="o">,</span> <span class="n">responseConverter</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">HttpServiceMethod</code> 是 <code class="highlighter-rouge">ServiceMethod</code> 的子类。而在<code class="highlighter-rouge">parseAnnotations</code> 方法中构造了<code class="highlighter-rouge">HttpServiceMethod</code>实例并返回。</p>

<p><strong>因此，<code class="highlighter-rouge">loadServiceMethod</code>方法返回的是<code class="highlighter-rouge">HttpServiceMehod</code>对象</strong></p>

<p>这样下面代码的执行实际上是执行了 <code class="highlighter-rouge">HttpServiceMehod</code> 的 <code class="highlighter-rouge">invoke</code> 方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">loadServiceMethod</span><span class="o">(</span><span class="n">method</span><span class="o">).</span><span class="na">invoke</span><span class="o">(</span><span class="n">args</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">args</span> <span class="o">:</span> <span class="n">emptyArgs</span><span class="o">);</span>
</code></pre></div></div>

<p>再次翻看上文中<code class="highlighter-rouge">HttpServiceMethod</code>类</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span> <span class="n">ReturnT</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">callAdapter</span><span class="o">.</span><span class="na">adapt</span><span class="o">(</span>
        <span class="k">new</span> <span class="n">OkHttpCall</span><span class="o">&lt;&gt;(</span><span class="n">requestFactory</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="n">callFactory</span><span class="o">,</span> <span class="n">responseConverter</span><span class="o">));</span>
  <span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">invoke</code> 方法里有执行了<code class="highlighter-rouge">callAdapter.adapt</code>方法，参数为<code class="highlighter-rouge">OkHttpCall</code>，这个类实际上就是对<code class="highlighter-rouge">okhttp</code>网络请求的封装，这里也可以看出<strong><code class="highlighter-rouge">retrofit</code>内部是使用了<code class="highlighter-rouge">okhttp</code>来执行网络请求的</strong></p>

<h5 id="calladapter">CallAdapter</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CallAdapter</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="c1">//..省略部分代码</span>
  <span class="n">T</span> <span class="nf">adapt</span><span class="o">(</span><span class="n">Call</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">call</span><span class="o">);</span>
  <span class="c1">//CallAdapter抽象工厂类</span>
  <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Factory</span> <span class="o">{</span>
    <span class="c1">//返回CallAdapter实例</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nd">@Nullable</span> <span class="n">CallAdapter</span><span class="o">&lt;?,</span> <span class="o">?&gt;</span> <span class="n">get</span><span class="o">(</span><span class="n">Type</span> <span class="n">returnType</span><span class="o">,</span> <span class="n">Annotation</span><span class="o">[]</span> <span class="n">annotations</span><span class="o">,</span>
        <span class="n">Retrofit</span> <span class="n">retrofit</span><span class="o">);</span>

    <span class="c1">//..省略部分代码</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这是一个接口，内部有一个<code class="highlighter-rouge">Factory</code>抽象工厂类，用于获取<code class="highlighter-rouge">CallAdapter</code>对象。</p>

<p><code class="highlighter-rouge">CallAdapter</code> 有很多子类，那 <code class="highlighter-rouge">callAdapter.adapt</code> 方法执行的是哪个具体类的方法呢？实际上，<strong>从调试代码中可以发现是调用<code class="highlighter-rouge">DefaultCallFactory</code>中的内部实现类</strong></p>

<p><img src="../images/calladapter-adapt.png" alt="" /></p>

<h5 id="defaultcallaapterfactory">DefaultCallAapterFactory</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="nc">DefaultCallAdapterFactory</span> <span class="kd">extends</span> <span class="n">CallAdapter</span><span class="o">.</span><span class="na">Factory</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="kd">final</span> <span class="n">CallAdapter</span><span class="o">.</span><span class="na">Factory</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultCallAdapterFactory</span><span class="o">();</span>

  <span class="nd">@Override</span> <span class="kd">public</span> <span class="nd">@Nullable</span> <span class="n">CallAdapter</span><span class="o">&lt;?,</span> <span class="o">?&gt;</span> <span class="n">get</span><span class="o">(</span>
      <span class="n">Type</span> <span class="n">returnType</span><span class="o">,</span> <span class="n">Annotation</span><span class="o">[]</span> <span class="n">annotations</span><span class="o">,</span> <span class="n">Retrofit</span> <span class="n">retrofit</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">getRawType</span><span class="o">(</span><span class="n">returnType</span><span class="o">)</span> <span class="o">!=</span> <span class="n">Call</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="n">Type</span> <span class="n">responseType</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="na">getCallResponseType</span><span class="o">(</span><span class="n">returnType</span><span class="o">);</span>
    <span class="c1">//返回一个CallAapter实例</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">CallAdapter</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Call</span><span class="o">&lt;?&gt;&gt;()</span> <span class="o">{</span>
      <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Type</span> <span class="nf">responseType</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">responseType</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Call</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">adapt</span><span class="o">(</span><span class="n">Call</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">call</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//将参数返回，而这个参数就是OKHttpCall的实例</span>
        <span class="k">return</span> <span class="n">call</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以发现，在<code class="highlighter-rouge">adapt</code>方法中就是将参数<code class="highlighter-rouge">call</code>返回。</p>

<p>所以下面代码返回的是<code class="highlighter-rouge">OkHttpCall</code>对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">loadServiceMethod</span><span class="o">(</span><span class="n">method</span><span class="o">).</span><span class="na">invoke</span><span class="o">(</span><span class="n">args</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">args</span> <span class="o">:</span> <span class="n">emptyArgs</span><span class="o">);</span>
</code></pre></div></div>

<p>综上</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//创建了Github接口的代理类</span>
<span class="n">GitHub</span> <span class="n">github</span> <span class="o">=</span> <span class="n">retrofit</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">GitHub</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">//执行接口的方法，其实就是调用了代理类的方法，并最终返回了一个OKhttpCall对象</span>
<span class="c1">//而这个对象就是对Okhttp的封装</span>
<span class="n">Call</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Contributor</span><span class="o">&gt;&gt;</span> <span class="n">call</span> <span class="o">=</span> <span class="n">github</span><span class="o">.</span><span class="na">contributors</span><span class="o">(</span><span class="s">"square"</span><span class="o">,</span> <span class="s">"retrofit"</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="0x02-执行结果">0x02 执行结果</h4>

<p>上文中获取到<code class="highlighter-rouge">OKhttpCall</code>对象，它只是把接口请求过程进行了封装，并没有真正的获取到接口数据。要获取到接口数据还需要调用<code class="highlighter-rouge">OkHttpCall.execute</code>方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Contributor</span><span class="o">&gt;</span> <span class="n">contributors</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="na">execute</span><span class="o">().</span><span class="na">body</span><span class="o">();</span>
</code></pre></div></div>

<h5 id="callexecute-或-callenqueue">Call.execute 或 Call.enqueue</h5>

<p>这里的请求过程与前文中《源码分析OKHttp执行过程》介绍的是类似的。接一下</p>

<p>打开<code class="highlighter-rouge">OkHttpCall.execute</code>方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Response</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">execute</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">okhttp3</span><span class="o">.</span><span class="na">Call</span> <span class="n">call</span><span class="o">;</span>

    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">executed</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">"Already executed."</span><span class="o">);</span>
      <span class="n">executed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">creationFailure</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">creationFailure</span> <span class="k">instanceof</span> <span class="n">IOException</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="o">(</span><span class="n">IOException</span><span class="o">)</span> <span class="n">creationFailure</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">creationFailure</span> <span class="k">instanceof</span> <span class="n">RuntimeException</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="o">(</span><span class="n">RuntimeException</span><span class="o">)</span> <span class="n">creationFailure</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="o">(</span><span class="n">Error</span><span class="o">)</span> <span class="n">creationFailure</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>

      <span class="n">call</span> <span class="o">=</span> <span class="n">rawCall</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">call</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">call</span> <span class="o">=</span> <span class="n">rawCall</span> <span class="o">=</span> <span class="n">createRawCall</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="o">|</span> <span class="n">RuntimeException</span> <span class="o">|</span> <span class="n">Error</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">throwIfFatal</span><span class="o">(</span><span class="n">e</span><span class="o">);</span> <span class="c1">//  Do not assign a fatal error to creationFailure.</span>
          <span class="n">creationFailure</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
          <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">canceled</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">call</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="nf">parseResponse</span><span class="o">(</span><span class="n">call</span><span class="o">.</span><span class="na">execute</span><span class="o">());</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>这里的执行逻辑也很简单</p>

<ul>
  <li>使用<code class="highlighter-rouge">synchronized</code>进行同步操作</li>
  <li>进行异常处理</li>
  <li>调用<code class="highlighter-rouge">createRawCall</code> 创建 <code class="highlighter-rouge">okhttp3.Call</code> 对象</li>
  <li>执行 <code class="highlighter-rouge">okhttp</code> 的<code class="highlighter-rouge">Call.execute</code>方法，并解析<code class="highlighter-rouge">response</code>后返回请求结果</li>
</ul>

<p>同样地，异步请求操作也是类似的</p>

<p>打开<code class="highlighter-rouge">OkHttpCall.enqueue</code>方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="kd">final</span> <span class="n">Callback</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">checkNotNull</span><span class="o">(</span><span class="n">callback</span><span class="o">,</span> <span class="s">"callback == null"</span><span class="o">);</span>

    <span class="n">okhttp3</span><span class="o">.</span><span class="na">Call</span> <span class="n">call</span><span class="o">;</span>
    <span class="n">Throwable</span> <span class="n">failure</span><span class="o">;</span>

    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">executed</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">"Already executed."</span><span class="o">);</span>
      <span class="n">executed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

      <span class="n">call</span> <span class="o">=</span> <span class="n">rawCall</span><span class="o">;</span>
      <span class="n">failure</span> <span class="o">=</span> <span class="n">creationFailure</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">call</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">failure</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="c1">//创建okhttp网络请求</span>
          <span class="n">call</span> <span class="o">=</span> <span class="n">rawCall</span> <span class="o">=</span> <span class="n">createRawCall</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">throwIfFatal</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
          <span class="n">failure</span> <span class="o">=</span> <span class="n">creationFailure</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">failure</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">callback</span><span class="o">.</span><span class="na">onFailure</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">failure</span><span class="o">);</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">canceled</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">call</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
    <span class="o">}</span>
	<span class="c1">//最终是执行了OkHttp中的call.enqueue方法</span>
    <span class="c1">//并回调相应的接口</span>
    <span class="n">call</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="k">new</span> <span class="n">okhttp3</span><span class="o">.</span><span class="na">Callback</span><span class="o">()</span> <span class="o">{</span>
      <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onResponse</span><span class="o">(</span><span class="n">okhttp3</span><span class="o">.</span><span class="na">Call</span> <span class="n">call</span><span class="o">,</span> <span class="n">okhttp3</span><span class="o">.</span><span class="na">Response</span> <span class="n">rawResponse</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Response</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">response</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">response</span> <span class="o">=</span> <span class="n">parseResponse</span><span class="o">(</span><span class="n">rawResponse</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">throwIfFatal</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
          <span class="n">callFailure</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
          <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
          <span class="n">callback</span><span class="o">.</span><span class="na">onResponse</span><span class="o">(</span><span class="n">OkHttpCall</span><span class="o">.</span><span class="na">this</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">t</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">}</span>

      <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">okhttp3</span><span class="o">.</span><span class="na">Call</span> <span class="n">call</span><span class="o">,</span> <span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">callFailure</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="kd">private</span> <span class="kt">void</span> <span class="nf">callFailure</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">callback</span><span class="o">.</span><span class="na">onFailure</span><span class="o">(</span><span class="n">OkHttpCall</span><span class="o">.</span><span class="na">this</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">t</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">});</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>这个方法其实最终都是执行了<code class="highlighter-rouge">okhttp</code>的相应方法。</p>

<h4 id="0x03-总结">0x03 总结</h4>

<p><code class="highlighter-rouge">Retrofit</code> 其实一种更加高级的网络应用框架，通过代理模式简化了接口的定义，无需提供接口的具体实现就可以完成网络接口请求的执行。它的底层实际上是封装了 <code class="highlighter-rouge">okhttp</code> 的执行过程，也把对网络的操作进行了封装，而对于程序猿来说只需要关注业务逻辑，对网络请求的具体实现不必关心。</p>

<p>例如在本文开头的实例中我们只需要定义接口，定义实体类，其他工作都交给了 <code class="highlighter-rouge">Retrofit</code> ，接下来就是<code class="highlighter-rouge">Magic</code>。</p>


        
        <div class="post_footer">
          <p>Published on Nov 03, 2018 in categories 
          
          <a href="http://localhost:4000/categories/#开源库" title="开源库">开源库</a>&nbsp;
          
          <p>
        </div>
        
        <ul class="prev_next">
            
            <li>
                <span>上一篇</span>
                <a href="/%E4%B8%80%E4%BB%BD%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%8D%95%E8%AF%8D%E5%88%97%E8%A1%A8-updating">一份程序猿单词列表（updating）</a>
            </li>
            
            
        </ul>
        <hr>
<div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

        

  

  
        <div id="container"></div>
        <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
        <script src="http://localhost:4000/js/gitment.browser.js"></script>
        <script>
        var gitment = new Gitment({
            id: '/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Retrofit%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B',
            owner: 'hylinux1024',
            repo: 'hylinux1024.github.io',
            oauth: {
                client_id: 'c79c9ae57765adcce459',
                client_secret: '09264b1c3c58033878872c924196898c9931a8e5',
            },
        })
        gitment.render('container')
        </script>
  


    </div>
</div>
<center><p style="font-size:0.5em;">Powered by <a href="http://jekyllrb.com">Jekyll</a> and Theme by <a href="http://github.com/mzlogin/jekyll-theme-solid">solid</a></p></center>
    </body>
</html>

